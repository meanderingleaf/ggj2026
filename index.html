<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>
    <!--  <script src="https://cdn.jsdelivr.net/npm/quickdraw.js@1.0.6/src/quickdraw.min.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@1.0.0"> </script>

    <script src="libs/riffwave.js"></script>
    <script src="libs/Blob.js"></script>
    <script src="libs/FileSaver.min.js"></script>
    <script src="libs/animalese.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            gap: 20px;
            font-family: Arial, sans-serif;
            background-color: #000;
        }
        #webcam-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #webcam {
            border: 2px solid #333;
            max-width: 500px;
            display: block;
        }
        #classifications {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            width: 400px;
            min-height: 100px;
            overflow-y: hidden
        }
        .detection-item {
            padding: 5px;
            margin: 3px 0;
            background: white;
            border-left: 4px solid #4CAF50;
            border-radius: 3px;
            height: 1em;
            overflow: hidden;
        }
        #game-container {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="webcam-container">
        <h2>Webcam Object Detection</h2>
        <video id="webcam" autoplay playsinline></video>
        <div id="classifications">
            <p>Loading model...</p>
        </div>
    </div>
    

    <script>
    let model;
    let video;
    let detectionData = [];
    let synth;

        function dataURItoBlob(dataURI) {
            // convert base64/URLEncoded data component to raw binary data held in a string
            var byteString;
            if (dataURI.split(',')[0].indexOf('base64') >= 0)
                byteString = atob(dataURI.split(',')[1]);
            else
                byteString = unescape(dataURI.split(',')[1]);

            // separate out the mime component
            var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]

            // write the bytes of the string to a typed array
            var ia = new Uint8Array(byteString.length);
            for (var i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }

            return new Blob([ia], {type:mimeString});
            }

    // Initialize webcam and model
    async function init() {
        video = document.getElementById('webcam');
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 500, height: 500 }
            });
            video.srcObject = stream;
        } catch (err) {
            console.error('Error accessing webcam:', err);
            document.getElementById('classifications').innerHTML = 'Error: Cannot access webcam. Please check permissions.';
            return;
        }

        // Load the COCO-SSD model
        model = await mobilenet.load(); //cocoSsd.load();
        document.getElementById('classifications').innerHTML = 'Model loaded! Starting detection...';
        
        // Start continuous detection
        detectObjects();



        synth = new Animalese('libs/animalese.wav', function() {
            console.log("Animalese model loaded.");
        });
    }

    // Continuous object detection
    async function detectObjects() {
        /*
        //Coco-SSD detection
        if (model && video.readyState === video.HAVE_ENOUGH_DATA) {
            const predictions = await model.detect(video);
            updateDetections(predictions);
        }
            */

        //MobileNet classification
        if (model && video.readyState === video.HAVE_ENOUGH_DATA) {
            const predictions = await model.classify(video);
            updateDetections(predictions);
        }
        requestAnimationFrame(detectObjects);
    }

    // Update the UI with detections
    function updateDetections(predictions) {

        detectionData = predictions;
        
        if (predictions.length === 0) {
            document.getElementById('classifications').innerHTML = '<p>No objects detected</p>';
            return;
        }


        //codo-SSD display
        /*
        let html = `<strong>Detected ${predictions.length} object(s):</strong><br>`;
        predictions.forEach(pred => {
            const confidence = (pred.score * 100).toFixed(1);
            html += `<div class="detection-item">
                <strong>${pred.class}</strong> - ${confidence}% confident
            </div>`;
        });
        */

        //MobileNet display
         let html = `<strong>Detected ${predictions.length} object(s):</strong><br>`;
         predictions.forEach(pred => {
            const confidence = (pred.probability * 100).toFixed(1);
            html += `<div class="detection-item">
                <strong>${pred.className}</strong> - ${confidence}% confident
            </div>`;
        });

        document.getElementById('classifications').innerHTML = html;
    }

    // Phaser scene
    class Example extends Phaser.Scene
    {
        progress = 0;
        progress_checking = false;
        progress_points = [0, -600, -1200, -3000];
        progress_prompts = [
            "Have I seen you before?",
            "Time o'clock",
            "Make sure its right.",
            "Put on your face."
        ];
        potential_responses =  { 
            "real": "trilobyte", 
            "sketchy": "pitcher", 
            "hasty": "vase"
        };
        correct_responses = [ this.potential_responses.sketchy, this.potential_responses.hasty, this.potential_responses.real, this.potential_responses.real ];
        txtDialog;
        player_velocity = -1;
        player;
        portraits = [];
        timer_circle;
        choice_timeout = 17000;
        choice_sprites = [];

        //pillow, sundial, mask

        preload ()
        {
            this.load.audio('bgm', 'assets/mysteriousweird.mp3');
            this.load.image('bgimage', 'assets/randomBG.png');
            this.load.image('ico_wavy', 'assets/ico_wavy.png');
            this.load.image('ico_octo', 'assets/ico_octo.png');
            this.load.image('ico_tri', 'assets/ico_tri.png');
            this.load.image('logo', 'assets/Somnabulismlogo.png');
            this.load.image('textbox', 'assets/textbox.png');
            this.load.bitmapFont('glitch_font', 'assets/glitch_font.png', 'assets/glitch_font.xml');


            this.load.spritesheet('brawler', 'assets/brawler48x48.png', { frameWidth: 48, frameHeight: 48 });
            this.load.spritesheet('psprite', 'assets/glitch_sprite.png', { frameWidth: 32, frameHeight: 32 });
            this.load.spritesheet('por_paperdoll', 'assets/paper_doll_portrait.png', { frameWidth: 1024, frameWidth: 1024 });
            this.load.spritesheet('por_cons', 'assets/cons_paper_portrait.png', { frameWidth: 1024, frameWidth: 1024 });
            this.load.spritesheet('por_person', 'assets/person_portrait.png', { frameWidth: 1024, frameWidth: 1024 });

            this.load.spritesheet('claysprite', 'assets/Claysprite.png', { frameWidth: 500, frameWidth: 500 });
            this.load.spritesheet('mcsprite', 'assets/Maincharactersprite.png', { frameWidth: 500, frameHeight: 500 });
            this.load.spritesheet('dollsprite', 'assets/Papergirlsprite.png', { frameWidth: 500, frameHeight: 500 });
            this.load.spritesheet('personsprite', 'assets/Papergirlsprite.png', { frameWidth: 500, frameHeight: 500 });
            //this.load.setBaseURL('https://meanderingleaf.github.io/ggj2026/');
            
        }
        
        update() {
            this.player.y += this.player_velocity;

            if(this.player.y < this.progress_points[this.progress] && !this.progress_checking) {
                //pause
                this.player_velocity = 0;

                //stop walking

                //show dialog
                this.textbox.visible = true;
                this.txtDialog.setText(this.progress_prompts[this.progress]);
                this.portraits[this.progress].visible = true;
                var tween = this.tweens.add({ targets: this.portraits[this.progress], y: { from: 1100, to: 500 }, ease: 'Bounce', duration: 700,});


                var audio = new Audio();
                audio.src = synth.Animalese(this.progress_prompts[this.progress], false, 1).dataURI;
                audio.play();

                 this.tweens.addCounter({
                    from: 0,
                    to: 360,
                    duration: this.choice_timeout,
                    onUpdate:  (tween) => {
                        // graphics.slice stuff
                        this.timer_circle.clear();
                        this.timer_circle.beginPath();
                        this.timer_circle.slice(0,0,45,Phaser.Math.DegToRad(tween.getValue()),Phaser.Math.DegToRad(360))
                        this.timer_circle.fillPath();
                        this.timer_circle.strokePath();
                        // use tween.getValue() to get the progress
                    },
                    onComplete: () =>{
                        //reset game
                        // this is the biggest copout but Im jammin
                        //window.location.reload();
                    }
                });
                
                //wait for next progress
                this.progress_checking = true;
            }

            //game over
            if( this.player.y < 5000 ) {
             //   window.close();
            }

            var do_progress = false;
            if(this.progress_checking) {
                //check detectionData for correct object
                for(let i=0; i<detectionData.length; i++) {

                    let detected_class = detectionData[i].className.toLowerCase();

                    if(detected_class.includes(this.correct_responses[this.progress])) {
                        do_progress = true;
                        break;
                    }
                }


                if(this.QKey.isDown) {
                    do_progress = true;
                }
            }


            if(do_progress) {
                this.portraits[this.progress].visible = false;
                this.progress++;
                this.progress_checking = false;
                this.player_velocity = -1;
                this.player.play('walk');
                this.txtDialog.setText("");
                this.textbox.visible = false;
            }

            //nasty double loop

            this.choice_sprites.forEach( (sprite, index) => {
                sprite.visible = false;
            });

            
            for(let i=0; i<detectionData.length; i++) {
                let detected_class = detectionData[i].className.toLowerCase();
                
                if(detected_class.includes(this.potential_responses.real)) {
                    this.choice_sprites[0].visible = true;
                }
                if(detected_class.includes(this.potential_responses.sketchy)) {
                     this.choice_sprites[1].visible = true;
                }
                if(detected_class.includes(this.potential_responses.hasty)) {
                     this.choice_sprites[2].visible = true;
                }
            }

            //this.progress++;
        }

        create ()
        {

           var backgroundMusic = this.sound.play('bgm', { loop: true });;

           this.add.image(200, 200, 'bgimage');

           this.player = this.add.sprite(270, 800, 'mcsprite').setScale(.2);

            //enconters - small sprites
            var glitches = []
            glitches[0] = this.add.sprite(200, this.progress_points[0], 'dollsprite').setScale(.5);
            glitches[1] = this.add.sprite(200, this.progress_points[1], 'claysprite').setScale(.5);
            glitches[2] = this.add.sprite(200, this.progress_points[2], 'personsprite').setScale(.5);
            glitches[3] = this.add.sprite(200, this.progress_points[3], 'personsprite').setScale(.5);

            //enconters - big sprites
                //There has to be some way to make a container / loop I am being lazy right now.
            this.portraits[0] = this.add.sprite(150, 400, 'por_paperdoll').setScale(.4);
            this.portraits[0].setScrollFactor(0);
            this.portraits[0].visible = false;
            this.portraits[1] = this.add.sprite(150, 400, 'por_cons').setScale(.4);
            this.portraits[1].setScrollFactor(0);
            this.portraits[1].visible = false;
            this.portraits[2] = this.add.sprite(150, 400, 'por_person').setScale(.4);
            this.portraits[2].setScrollFactor(0);
            this.portraits[2].visible = false;
            this.portraits[3] = this.add.sprite(150, 400, 'por_person').setScale(.4);
            this.portraits[3].setScrollFactor(0);
            this.portraits[3].visible = false;

           this.anims.create({
                key: 'walk',
                frames: this.anims.generateFrameNumbers('mcsprite', { frames: [ 9,10,11 ] }),
                frameRate: 8,
                repeat: -1
            });

            this.anims.create({
                key: 'idle_person',
                frames: this.anims.generateFrameNumbers('por_person', { frames: [ 0, 1, 2, 3, 4, 5, 6, 7 ] }),
                frameRate: 2,
                repeat: -1
            });
             this.portraits[3].play('idle_person');

            this.anims.create({
                key: 'idle_doll',
                frames: this.anims.generateFrameNumbers('por_paperdoll', { frames: [ 0, 1 ] }),
                frameRate: 2,
                repeat: -1
            });
            this.portraits[0].play('idle_doll');

            this.anims.create({
                key: 'idle_cons',
                frames: this.anims.generateFrameNumbers('por_cons', { frames: [ 0, 1, 2, 3, 4, 5, 6, 7 ] }),
                frameRate: 2,
                repeat: -1
            });
            this.portraits[1].play('idle_cons');

            this.anims.create({
                key: 'doll_idle',
                frames: [ 0, 1, 2 ],
                frames: this.anims.generateFrameNumbers('dollsprite', { frames: [ 0, 1, 2 ] }),
                frameRate: 2,
                repeat: -1
            });
            glitches[0].play('doll_idle');

            this.anims.create({
                key: 'clay_idle',
                frames: [ 0, 1, 2 ],
                frames: this.anims.generateFrameNumbers('claysprite', { frames: [ 0, 1, 2 ] }),
                frameRate: 2,
                repeat: -1
            });
            glitches[1].play('clay_idle');

            this.anims.create({
                key: 'person_idle',
                frames: [ 0, 1, 2 ],
                frames: this.anims.generateFrameNumbers('personsprite', { frames: [ 0, 1, 2 ] }),
                frameRate: 2,
                repeat: -1
            });
            glitches[2].play('person_idle');
            glitches[3].play('person_idle');

            //Intrusctions
            this.add.bitmapText(10, 600, "glitch_font", "(Sonanmbulism)");
            this.add.image(300, 600, 'logo').setScale(0.14);
            this.add.text(10, 400, "Grab your masks", { fontFamily: 'Arial, sans-serif' });
            this.add.text(10, 200, "Use them to pass", { fontFamily: 'Arial, sans-serif' });
            this.add.text(10, -3000, "Its real.", { fontFamily: 'Arial, sans-serif' });
            this.add.text(10, -3200, "Its always been real.",{ fontFamily: 'Arial, sans-serif' });
            this.add.text(10, -3400, "Discard,",{ fontFamily: 'Arial, sans-serif' });
            this.add.text(10, -3600, "Turn,",{ fontFamily: 'Arial, sans-serif' });
            this.add.text(10, -4000, "Awake.", { fontFamily: 'Arial, sans-serif' });


            this.player.play('walk');
            this.cameras.main.startFollow(this.player);
            this.cameras.main.postFX.addTiltShift(0.13, 1.1, 0.2);

            //teext
            this.textbox = this.add.image(400, 530, 'textbox').setScrollFactor(0).setScale(.6);
            this.textbox.visible = false;

            this.txtDialog = this.add.bitmapText(300, 500, 'glitch_font', '');
            this.txtDialog.setFontSize(21);
            this.txtDialog.setScrollFactor(0);

            this.timer_circle = this.add.graphics();
            this.timer_circle.x = 470;
            this.timer_circle.y = 70;
            this.timer_circle.setScrollFactor(0);
            this.timer_circle.lineStyle(4, 0xff00ff, 1);
            this.timer_circle.fillStyle(0xFFFFFF, 1);

            //choice sprites
            this.choice_sprites[0] = this.add.image(350, 900, 'ico_wavy').setScale(0.5);
            this.choice_sprites[0].setScrollFactor(0);
            this.choice_sprites[1] = this.add.image(420, 900, 'ico_octo').setScale(0.5);
            this.choice_sprites[1].setScrollFactor(0);
            this.choice_sprites[2] = this.add.image(490, 900, 'ico_tri').setScale(0.5);
            this.choice_sprites[2].setScrollFactor(0);
        

            this.QKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q);


            // arc (x, y, radius, startAngle, endAngle, anticlockwise)
            //this.timer_circle.arc(0, 0, 50, Phaser.Math.DegToRad(90), Phaser.Math.DegToRad(180), true);


            /*
            this.add.image(400, 300, 'sky');

            const particles = this.add.particles(0, 0, 'red', {
                speed: 100,
                scale: { start: 1, end: 0 },
                blendMode: 'ADD'
            });

            const logo = this.physics.add.image(400, 100, 'logo');

            logo.setVelocity(100, 200);
            logo.setBounce(1, 1);
            logo.setCollideWorldBounds(true);

            particles.startFollow(logo);
            */
        }
    }

    const config = {
        type: Phaser.AUTO,
        width: 540,
        height: 960,
        parent: 'game-container',
        scene: Example,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 200 }
            }
        }
    };

    const game = new Phaser.Game(config);

    // Start webcam and model when page loads
    window.addEventListener('load', init);
    </script>

</body>
</html>