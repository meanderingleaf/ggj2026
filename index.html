<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>
    <!--  <script src="https://cdn.jsdelivr.net/npm/quickdraw.js@1.0.6/src/quickdraw.min.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@1.0.0"> </script>

    <script src="libs/riffwave.js"></script>
    <script src="libs/Blob.js"></script>
    <script src="libs/FileSaver.min.js"></script>
    <script src="libs/animalese.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            gap: 20px;
            font-family: Arial, sans-serif;
        }
        #webcam-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #webcam {
            border: 2px solid #333;
            max-width: 500px;
            display: none;
        }
        #classifications {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            width: 400px;
            min-height: 100px;
            overflow-y: hidden
        }
        .detection-item {
            padding: 5px;
            margin: 3px 0;
            background: white;
            border-left: 4px solid #4CAF50;
            border-radius: 3px;
            height: 1em;
            overflow: hidden;
        }
        #game-container {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="webcam-container">
        <h2>Webcam Object Detection</h2>
        <video id="webcam" autoplay playsinline></video>
        <div id="classifications">
            <p>Loading model...</p>
        </div>
    </div>
    

    <script>
    let model;
    let video;
    let detectionData = [];
    let synth;

        function dataURItoBlob(dataURI) {
            // convert base64/URLEncoded data component to raw binary data held in a string
            var byteString;
            if (dataURI.split(',')[0].indexOf('base64') >= 0)
                byteString = atob(dataURI.split(',')[1]);
            else
                byteString = unescape(dataURI.split(',')[1]);

            // separate out the mime component
            var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]

            // write the bytes of the string to a typed array
            var ia = new Uint8Array(byteString.length);
            for (var i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }

            return new Blob([ia], {type:mimeString});
            }

    // Initialize webcam and model
    async function init() {
        video = document.getElementById('webcam');
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 500, height: 500 }
            });
            video.srcObject = stream;
        } catch (err) {
            console.error('Error accessing webcam:', err);
            document.getElementById('classifications').innerHTML = 'Error: Cannot access webcam. Please check permissions.';
            return;
        }

        // Load the COCO-SSD model
        model = await mobilenet.load(); //cocoSsd.load();
        document.getElementById('classifications').innerHTML = 'Model loaded! Starting detection...';
        
        // Start continuous detection
        detectObjects();



        synth = new Animalese('libs/animalese.wav', function() {
            console.log("Animalese model loaded.");
        });
    }

    // Continuous object detection
    async function detectObjects() {
        /*
        //Coco-SSD detection
        if (model && video.readyState === video.HAVE_ENOUGH_DATA) {
            const predictions = await model.detect(video);
            updateDetections(predictions);
        }
            */

        //MobileNet classification
        if (model && video.readyState === video.HAVE_ENOUGH_DATA) {
            const predictions = await model.classify(video);
            updateDetections(predictions);
        }
        requestAnimationFrame(detectObjects);
    }

    // Update the UI with detections
    function updateDetections(predictions) {

        detectionData = predictions;
        
        if (predictions.length === 0) {
            document.getElementById('classifications').innerHTML = '<p>No objects detected</p>';
            return;
        }


        //codo-SSD display
        /*
        let html = `<strong>Detected ${predictions.length} object(s):</strong><br>`;
        predictions.forEach(pred => {
            const confidence = (pred.score * 100).toFixed(1);
            html += `<div class="detection-item">
                <strong>${pred.class}</strong> - ${confidence}% confident
            </div>`;
        });
        */

        //MobileNet display
         let html = `<strong>Detected ${predictions.length} object(s):</strong><br>`;
         predictions.forEach(pred => {
            const confidence = (pred.probability * 100).toFixed(1);
            html += `<div class="detection-item">
                <strong>${pred.className}</strong> - ${confidence}% confident
            </div>`;
        });

        document.getElementById('classifications').innerHTML = html;
    }

    // Phaser scene
    class Example extends Phaser.Scene
    {
        progress = 0;
        progress_checking = false;
        progress_points = [20, -100, -150, -200];
        progress_prompts = [
            "I see a cat! Meow!",
            "There's a bottle ahead!",
            "Is that a cell phone?",
            "Look, a book!"
        ];
        correct_responses = [ "oxygen mask", "bottle", "cell phone", "book" ];
        txtDialog;
        player_velocity = -1;
        player;
        portraits = [];

        preload ()
        {
            this.load.audio('bgm', 'assets/mysteriousweird.mp3');
            this.load.image('bgimage', 'assets/randomBG.png');
            this.load.spritesheet('brawler', 'assets/brawler48x48.png', { frameWidth: 48, frameHeight: 48 });
            this.load.spritesheet('psprite', 'assets/glitch_sprite.png', { frameWidth: 32, frameHeight: 32 });
            this.load.spritesheet('por_paperdoll', 'assets/paper_doll_portrait.png', { frameWidth: 1024, frameWidth: 1024 });
            this.load.spritesheet('por_cons', 'assets/cons_paper_portrait.png', { frameWidth: 1024, frameWidth: 1024 });
            this.load.spritesheet('por_person', 'assets/person_portrait.png', { frameWidth: 1024, frameWidth: 1024 });

            //this.load.setBaseURL('https://meanderingleaf.github.io/ggj2026/');
            
        }
        
        update() {
            this.player.y += this.player_velocity;

            if(this.player.y < this.progress_points[this.progress] && !this.progress_checking) {
                //pause
                this.player_velocity = 0;

                //stop walking

                //show dialog
                this.txtDialog.setText(this.progress_prompts[this.progress]);
                this.portraits[this.progress].visible = true;
                var tween = this.tweens.add({ targets: this.portraits[this.progress], y: { from: 1100, to: 750 }, ease: 'Bounce', duration: 700,});


                var audio = new Audio();
                audio.src = synth.Animalese(this.progress_prompts[this.progress], false, 1).dataURI;
                audio.play();
                
                //wait for next progress
                this.progress_checking = true;
            }

            if(this.progress_checking) {
                //check detectionData for correct object
                for(let i=0; i<detectionData.length; i++) {

                    let detected_class = detectionData[i].className.toLowerCase();
                    if(detected_class.includes(this.correct_responses[this.progress])) {
                        //correct object detected
                        this.portraits[this.progress].visible = false;
                        this.progress++;
                        this.txtDialog.setText("Great! Keep going!");
                        this.progress_checking = false;
                        setTimeout( () => {
                            this.player_velocity = -1;
                            this.player.play('walk');
                            this.txtDialog.setText("");
                        }, 2000);
                        break;
                    }
                }
            }

            //this.progress++;
        }

        create ()
        {

           var backgroundMusic = this.sound.play('bgm', { loop: true });;

           this.add.image(200, 200, 'bgimage');

           this.player = this.add.sprite(270, 800, 'brawler');

            //enconters - small sprites
            this.add.sprite(200, 0, 'psprite');
            this.add.sprite(200, 60, 'psprite');
            this.add.sprite(200, -100, 'psprite');
            this.add.sprite(200, -200, 'psprite');  

            //enconters - big sprites
                //There has to be some way to make a container / loop I am being lazy right now.
            this.portraits[0] = this.add.sprite(150, 600, 'por_paperdoll').setScale(.4);
            this.portraits[0].setScrollFactor(0);
            this.portraits[0].visible = false;
            this.portraits[1] = this.add.sprite(150, 600, 'por_cons').setScale(.4);
             this.portraits[1].setScrollFactor(0);
             this.portraits[1].visible = false;
            this.portraits[2] = this.add.sprite(150, 600, 'por_person').setScale(.4);
             this.portraits[2].setScrollFactor(0);
             this.portraits[2].visible = false;
            this.portraits[3] = this.add.sprite(150, 600, 'por_person').setScale(.4);
             this.portraits[3].setScrollFactor(0);
             this.portraits[3].visible = false;

           this.anims.create({
                key: 'walk',
                frames: this.anims.generateFrameNumbers('brawler', { frames: [ 0, 1, 2, 3 ] }),
                frameRate: 8,
                repeat: -1
            });

            this.anims.create({
                key: 'idle_person',
                frames: this.anims.generateFrameNumbers('por_person', { frames: [ 0, 1, 2, 3, 4, 5, 6, 7 ] }),
                frameRate: 2,
                repeat: -1
            });
             this.portraits[3].play('idle_person');

            this.anims.create({
                key: 'idle_doll',
                frames: this.anims.generateFrameNumbers('por_paperdoll', { frames: [ 0, 1 ] }),
                frameRate: 2,
                repeat: -1
            });
            this.portraits[0].play('idle_doll');

            this.anims.create({
                key: 'idle_cons',
                frames: this.anims.generateFrameNumbers('por_cons', { frames: [ 0, 1, 2, 3, 4, 5, 6, 7 ] }),
                frameRate: 2,
                repeat: -1
            });
             this.portraits[1].play('idle_cons');


            this.player.play('walk');
            this.cameras.main.startFollow(this.player);

            this.txtDialog = this.add.text(100, 800, '', { fontFamily: 'Arial, sans-serif' });
            this.txtDialog.setScrollFactor(0);

            /*
            this.add.image(400, 300, 'sky');

            const particles = this.add.particles(0, 0, 'red', {
                speed: 100,
                scale: { start: 1, end: 0 },
                blendMode: 'ADD'
            });

            const logo = this.physics.add.image(400, 100, 'logo');

            logo.setVelocity(100, 200);
            logo.setBounce(1, 1);
            logo.setCollideWorldBounds(true);

            particles.startFollow(logo);
            */
        }
    }

    const config = {
        type: Phaser.AUTO,
        width: 540,
        height: 960,
        parent: 'game-container',
        scene: Example,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 200 }
            }
        }
    };

    const game = new Phaser.Game(config);

    // Start webcam and model when page loads
    window.addEventListener('load', init);
    </script>

</body>
</html>